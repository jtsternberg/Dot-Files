# view modified files in a directory
ls-mod-dir() { git ls-files -m -- "$*" }

# reset modified files in a directory
reset-mod-dir() { git checkout -- `git ls-files -m -- "$*"` }

# Remove untracked files (use caution)
remove-untracked() { rm -rf `git ls-files --other --exclude-standard` }

# Get all files changed b/w commits
gdifflog() { git log --name-only --pretty=oneline --full-index $*..HEAD | grep -vE '^[0-9a-f]{40} ' | sort | uniq }

# Delete a remote branch.. because the syntax is so weird
deleteremote() { git push $1 :$2 }

# Search commits for a string or code
searchcommits() { git log -G "$*" --pretty=format:"%C(yellow)%h %Creset%s %Cgreen(%cr) %Cblue[%cn - %ce]" --decorate }

# Reset-checkout.. checks out branch, removes untracked files, and re-inits submodules
checkout-reset() {
	git checkout $1 && remove-untracked && git submodule update --init --recursive
}

diffcommit() {
	git difftool $1~1 $1 ${2:-}
}

glasttag() {
	git describe --tags --abbrev=0;
}

gdeletelasttag() {
	git tag -d `glasttag`;
}

gnexttag() {
	git-nexttag;
}

gnewtag() {
	NEXTTAG=${1:-`git-nexttag`};
	git tag -a $NEXTTAG -m \"${2:-"$NEXTTAG"}\";
	git tag;
}

#### Now, in your shell you can do
#### git cr <TAB>
#### and get an autocomplete of available branches, just like "git checkout <TAB>"
_git_cr () {
	# you can return anything here for the autocompletion for example all the branches
	__gitcomp_nl "$(__git_refs)"
}

## Add tab completion for git diffmod <refs>.
_git_diffmod () {
	__gitcomp_nl "$(__git_refs)"
}

## Add tab completion for git move <branch>.
_git_move() {
  _git_branch
}
